import argparse
import os
import sys

import numpy as np
import torch
import torch.nn as nn
from torch import optim

from models.MLP import MLP

from utils.dataset import BasicDataset
from torch.utils.data import DataLoader, random_split

dir_img = "data/images/"
dir_mask = "data/labels/"
dir_checkpoints = "checkpoints/"

def inference(net,
              device,
              epochs=100,
              batch_size=32,
              lr=0.001,
              val_percent=0.1,
              save_cp=True,
              ):
    pass
    
def get_args():
    parser = argparse.ArgumentParser(description='Train the PointRender on images and pre-processed labels',
                                     formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('-e', '--epochs', metavar='E', type=int, default=5,
                        help='Number of epochs', dest='epochs')
    parser.add_argument('-b', '--batch-size', metavar='B', type=int, nargs='?', default=1,
                        help='Batch size', dest='batchsize')
    parser.add_argument('-l', '--learning-rate', metavar='LR', type=float, nargs='?', default=0.1,
                        help='Learning rate', dest='lr')
    parser.add_argument('-f', '--load', dest='load', type=str, default=False,
                        help='Load model from a .pth file')
    parser.add_argument('-v', '--validation', dest='val', type=float, default=10.0,
                        help='Percent of the data that is used as validation (0-100)')

    return parser.parse_args()


if __name__ == '__main__':
    args = get_args()
    device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')

    net = MLP(1,3)

    if args.load:
        net.lead_state_dict(
            torch.load(args.load, map_location=device)
        )

    net.to(device=device)

    try:
        train_net(net=net,
                  epochs=args.epochs,
                  batch_size=args.batchsize,
                  lr=args.lr,
                  device=device,
                  val_percent=args.val / 100)
    except KeyboardInterrupt:
        torch.save(net.state_dict(), 'INTERRUPTED.pth')
        logging.info('Saved interrupt')
        try:
            sys.exit(0)
        except SystemExit:
            os._exit(0)
